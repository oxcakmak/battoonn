class GoogleAuthenticator {
  constructor(
    skew = Math.round(5),
    charset = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    blocksize = 64,
    sha1BlockSize = 64
  ) {
    // Validate and potentially adjust skew based on environment or security policy
    if (skew < 0 || skew > 15) {
      console.warn("Invalid skew value provided. Using default of 5.");
      this.skew = 5;
    } else {
      this.skew = skew;
    }

    if (typeof charset !== "string" || charset.length !== 32) {
      throw new Error("Invalid character set provided");
    }
    this.charset = charset;

    // Block size for SHA1
    this.blocksize = blocksize;
    // SHA1 block size is always 64 bytes
    this.sha1BlockSize = sha1BlockSize;
  }

  /**
   * Encodes a string into Base32 representation.
   *
   * @param {string} str The string to encode.
   * @returns {string} The Base32 encoded string.
   * @throws {Error} If the input string is invalid.
   */
  encode(str) {
    if (typeof str !== "string") {
      throw new TypeError("Input string expected");
    }

    const bin = this.str2bin(str);
    let encoded = "";

    for (let i = 0; i < bin.length; i += 5) {
      const chunk = bin.slice(i, i + 5).padEnd(5, "0");
      const index = parseInt(chunk, 2);
      encoded += this.charset[index];
    }

    return encoded.replace(/0+$/, "");
  }

  /**
   * Decodes a Base32 string into its original representation.
   *
   * @param {string} str The Base32 encoded string.
   * @returns {string} The decoded string.
   * @throws {Error} If the input string is invalid Base32.
   */
  decode(str) {
    if (typeof str !== "string") {
      throw new Error("Input string expected");
    }

    const padLength = (str.length * 5) % 8;
    str = str.padEnd(str.length + padLength, "=");

    let decoded = "";
    for (let i = 0; i < str.length; i++) {
      const charIndex = this.charset.indexOf(str[i]);

      // if (charIndex === -1 || str[i].includes("=")) { throw new Error("Invalid character in Base32 string"); }

      const binary = charIndex.toString(2).padStart(5, "0");
      decoded += binary;
    }

    return this.bin2str(decoded.slice(0, -padLength));

    // return "This function is under construction";
  }

  /**
   * Converts a string to its binary representation.
   *
   * @param {string} str The string to convert.
   * @returns {string} The binary representation as a string.
   */
  str2bin(str) {
    return str
      .split("")
      .map((ch) => ch.charCodeAt(0).toString(2).padStart(8, "0"))
      .join("");
  }

  /**
   * Converts a binary string to its character representation.
   *
   * @param {string} str The binary string to convert.
   * @returns {string} The character representation.
   */
  bin2str(str) {
    return str
      .match(/(.{8})/g)
      .map((byte) => String.fromCharCode(parseInt(byte, 2)))
      .join("");
  }

  /**
   * Verifies a user-provided code against a time-based one-time password (TOTP) generated using the secret key.
   *
   * @param {string} secretkey Base32-encoded secret key
   * @param {string} code User-provided code (typically 6 digits)
   * @returns {Promise<boolean>} Resolves to true if the code is valid, false otherwise. Rejects with an Error if an issue occurs.
   */
  async verifyCode(secretkey, code) {
    if (!secretkey || !code) {
      return Promise.reject(
        new Error("Missing required parameters: secretkey and code")
      );
    }

    let decodedKey;
    try {
      decodedKey = await this.decode(secretkey);
    } catch (error) {
      return Promise.reject(
        new Error("Failed to decode secret key: " + error.message)
      );
    }

    if (code.length !== 6) {
      return Promise.reject(
        new Error("Invalid code length. Expected 6 digits.")
      );
    }

    const timestamp = Math.floor(Date.now() / 30000); // Time in 30-second intervals

    for (let i = -this.skew; i <= this.skew; i++) {
      const checkTime = timestamp + i;
      const calculatedCode = await this.generateHOTP(decodedKey, checkTime);

      if (calculatedCode === code) {
        return true;
      }
    }

    return false;
  }

  /**
   * Generates a time-based one-time password (HOTP) using the provided secret key and timestamp.
   *
   * @param {Uint8Array} key Secret key as a byte array
   * @param {number} counter Time-based counter value
   * @returns {Promise<string>} Resolves to the generated HOTP code (6 digits). Rejects with an Error if an issue occurs.
   */
  async generateHOTP(key, counter) {
    const counterBytes = new Uint8Array(8);
    for (let i = 7; i >= 0; i--) {
      counterBytes[i] = counter & 0xff;
      counter >>= 8;
    }

    // **Important Security Note:**
    // Replace with a secure HMAC-SHA1 implementation that considers key handling and secure random number generation.
    const hash = await this.hmacSha1(key, counterBytes);

    return this.truncateHOTP(hash);
  }

  /**
   * Truncates the generated HOTP hash to a 6-digit code.
   *
   * @param {Uint8Array} hash HMAC-SHA1 hash of the counter value
   * @returns {string} The truncated HOTP code (6 digits)
   */
  truncateHOTP(hash) {
    const offset = hash[19] & 0xf;
    const binary =
      ((hash[offset] & 0x7f) << 24) |
      ((hash[offset + 1] & 0xff) << 16) |
      ((hash[offset + 2] & 0xff) << 8) |
      (hash[offset + 3] & 0xff);
    return String(binary % Math.pow(10, 6)).padStart(6, "0");
  }

  wordsToBytes(words) {
    var bytes = [];
    for (var i = 0, len = words.length * 32; i < len; i += 8) {
      bytes.push((words[i >>> 5] >>> (24 - (i % 32))) & 0xff);
    }
    return bytes;
  }

  bytesToHex(bytes) {
    var hex = [];
    for (var i = 0, len = bytes.length; i < len; i++) {
      hex.push((bytes[i] >>> 4).toString(16));
      hex.push((bytes[i] & 0xf).toString(16));
    }
    return hex.join("");
  }

  sha1(message) {
    var blocksize = 64;

    function rotate_left(n, s) {
      return (n << s) | (n >>> (32 - s));
    }

    function preprocess(message) {
      var m = message.concat([0x80]);
      while (m.length % blocksize !== 56) {
        m.push(0x00);
      }
      m.push(0x00);
      m.push(0x00);
      m.push(0x00);
      m.push(message.length * 8);
      return m;
    }

    var h0 = 0x67452301;
    var h1 = 0xefcdab89;
    var h2 = 0x98badcfe;
    var h3 = 0x10325476;
    var h4 = 0xc3d2e1f0;

    var w = [];
    var m = preprocess(message);

    for (var i = 0, len = m.length; i < len; i += blocksize) {
      var chunk = m.slice(i, i + blocksize);
      for (var j = 0; j < blocksize; j += 4) {
        w[j / 4] =
          (chunk[j] << 24) |
          (chunk[j + 1] << 16) |
          (chunk[j + 2] << 8) |
          chunk[j + 3];
      }
      for (var j = 16; j < 80; j++) {
        w[j] = rotate_left(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
      }

      var a = h0;
      var b = h1;
      var c = h2;
      var d = h3;
      var e = h4;

      for (var t = 0; t < 80; t++) {
        var temp =
          (rotate_left(a, 5) +
            e +
            w[t] +
            (t < 20
              ? 0x5a827999
              : t < 40
              ? 0x6ed9eba1
              : t < 60
              ? 0x8f1bbcdc
              : 0xca62c1d6)) &
          0xffffffff;
        e = d;
        d = c;
        c = rotate_left(b, 30);
        b = a;
        a = temp;
      }

      h0 = (h0 + a) & 0xffffffff;
      h1 = (h1 + b) & 0xffffffff;
      h2 = (h2 + c) & 0xffffffff;
      h3 = (h3 + d) & 0xffffffff;
      h4 = (h4 + e) & 0xffffffff;
    }

    return [h0, h1, h2, h3, h4];
  }

  hmacSha1(message, key) {
    var blocksize = 64;
    var hashsize = 20;
  
    // Ensure key is an array of bytes
    if (!Array.isArray(key)) {
      key = Array.from(key); // Convert string or other types to array
    }
  
    if (key.length > blocksize) {
      key = this.sha1(key); // Assuming sha1 returns an array
    }
    key = key.concat(Array(blocksize - key.length).fill(0));
  
    var o_key_pad = [];
    var i_key_pad = [];
    for (var i = 0; i < blocksize; i++) {
      o_key_pad[i] = key[i] ^ 0x5c;
      i_key_pad[i] = key[i] ^ 0x36;
    }
  
    var i_key_pad_concat = i_key_pad.concat(message);
    var i_key_pad_hash = this.sha1(i_key_pad_concat);
    var o_key_pad_concat = o_key_pad.concat(i_key_pad_hash);
    var hmac = this.sha1(o_key_pad_concat);
  
    return this.bytesToHex(this.wordsToBytes(hmac));
  }

  forApp(str, secret) {
    if (!str || !secret) {
      return Promise.reject(
        new Error("Missing required parameters: str and secret")
      );
    }

    if (typeof str !== "string") {
      throw new TypeError("Input string expected");
    }

    if (typeof secret !== "string") {
      throw new TypeError("Input string expected");
    }

    return "otpauth://totp/" + str + "?secret=" + secret;
  }
}

module.exports = GoogleAuthenticator;
